# -*- coding: utf-8 -*-
"""Streamlite.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rp8ywUnPKH0WS7uLk3IC8abU5MUidVBi
"""

# streamlit_app.py


# ---------------------------
# Imports
# ---------------------------
import streamlit as st
import pandas as pd
import numpy as np
import joblib
import os
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="Mood Reboot — Digital Detox", layout="wide")
sns.set_theme(style="whitegrid")

# ---------------------------
# Paths (adjust only if your repo structure differs)
# ---------------------------
MODELS_DIR = "models"
DATA_DIR = "data"
   # expects repo root/data/

# fallback if running from repo root directly
if not os.path.isdir(MODELS_DIR):
    MODELS_DIR = os.path.join(os.getcwd(), "models")
if not os.path.isdir(DATA_DIR):
    DATA_DIR = os.path.join(os.getcwd(), "data")

# ---------------------------
# Load models & artifacts (safe load with friendly errors)
# ---------------------------
lr = None
scaler_reg = None
try:
    lr = joblib.load(os.path.join(MODELS_DIR, "linear_mood_change_model.joblib"))
    scaler_reg = joblib.load(os.path.join(MODELS_DIR, "scaler_reg.joblib"))
except Exception as e:
    st.error(f"Could not load regression model/scaler from '{MODELS_DIR}'.\nError: {e}")
    st.stop()

# Classification artifacts (optional)
clf = None
scaler_clf = None
le = None
if os.path.exists(os.path.join(MODELS_DIR, "logistic_difficulty_model.joblib")):
    try:
        clf = joblib.load(os.path.join(MODELS_DIR, "logistic_difficulty_model.joblib"))
        scaler_clf = joblib.load(os.path.join(MODELS_DIR, "scaler_clf.joblib"))
        le = joblib.load(os.path.join(MODELS_DIR, "label_encoder_difficulty.joblib"))
    except Exception as e:
        st.warning("Classification artifacts found but couldn't be loaded. Classification will be disabled.")
        st.write(e)

# ---------------------------
# UI Layout
# ---------------------------
st.subheader("Model Predictions")
col1, col2 = st.columns(2)

# Prepare input dataframe (columns named exactly like your CSV)
# ---------------- Sidebar inputs (define these FIRST) ----------------
# ---------------- Sidebar inputs (define these FIRST) ----------------
# ---------------- Sidebar inputs (define these FIRST) ----------------
# ---------------- Sidebar inputs ----------------
with st.sidebar:
    st.header("Your Inputs")
    duration = st.selectbox("Detox Duration (hrs)", options=[24, 48], index=0)
    baseline_mood = st.slider("Baseline Mood (0–10)", 0, 10, 5)
    baseline_stress = st.slider("Baseline Stress (%)", 0, 100, 60)
    baseline_sleep = st.slider("Baseline Sleep Quality (0–10)", 0, 10, 6)
    baseline_focus = st.slider("Baseline Focus (0–10)", 0, 10, 5)
    screen_time = st.slider("Screen Time (hrs/day)", 0, 24, 6)
    sleep_hours = st.slider("Average Sleep Hours (per night)", 0, 12, 7)

# ---------------- Build input dataframe ----------------
# Use the same columns your model expects
reg_features = [
    "Detox Duration",
    "Baseline Mood",
    "Baseline Stress",
    "Baseline Sleep",
    "Baseline Focus",
    "Screen Time",
    "Sleep Hours"
]

input_dict = {
    "Detox Duration": int(duration),
    "Baseline Mood": int(baseline_mood),
    "Baseline Stress": int(baseline_stress),
    "Baseline Sleep": int(baseline_sleep),
    "Baseline Focus": int(baseline_focus),
    "Screen Time": int(screen_time),
    "Sleep Hours": int(sleep_hours)
}

input_df = pd.DataFrame([input_dict])

# Ensure order
X_reg = input_df[reg_features]

# ---------------- Regression Prediction ----------------
try:
    X_reg_scaled = scaler_reg.transform(X_reg)
    pred_mood_change = float(lr.predict(X_reg_scaled)[0])
    st.metric(label="Predicted Mood Improvement (0–10)", value=f"{pred_mood_change:.2f}")
    st.write("Predicted Post Mood:", round(min(10, baseline_mood + pred_mood_change), 2))
except Exception as e:
    st.error(f"Prediction failed — check model & feature names. Error: {e}")

# ---------------- Classification (if available) ----------------
if clf is not None and scaler_clf is not None and le is not None:
    try:
        X_clf_scaled = scaler_clf.transform(X_reg)
        pred_class = clf.predict(X_clf_scaled)[0]
        pred_label = le.inverse_transform([pred_class])[0]
        st.metric(label="Predicted Detox Difficulty", value=pred_label)
    except Exception as e:
        st.warning(f"Classification failed (check classifier features). Error: {e}")
else:
    st.info("Classification model not available. Upload classification artifacts into models/ if needed.")

# ---------------- Regression prediction (use same order / names that scaler/model expect) ----------------
X_reg = input_df[reg_features]   # this will guarantee correct column names & order
X_reg_scaled = scaler_reg.transform(X_reg)
pred_mood_change = float(lr.predict(X_reg_scaled)[0])
st.metric(label="Predicted Mood Improvement (0–10)", value=f"{pred_mood_change:.2f}")

# Optional: show predicted post mood
st.write("Predicted Post Mood:", min(10, baseline_mood + pred_mood_change).__round__(2))

# ---------------- Classification (if available) ----------------
if clf is not None and scaler_clf is not None and le is not None:
    # If classifier was trained on same reg_features, use same X_reg; otherwise adjust similarly
    X_clf_scaled = scaler_clf.transform(X_reg)
    pred_class = clf.predict(X_clf_scaled)[0]
    pred_label = le.inverse_transform([pred_class])[0]
    st.metric(label="Predicted Detox Difficulty", value=pred_label)
else:
    st.info("Classification model not available. Upload classification artifacts into models/ if needed.")



# Regression input features used during training (match your training script)
reg_features = ["Detox Duration", "Stress Reduction", "Sleep Improvement", "Screen Time"]
X_reg = input_df[reg_features]

# Scale & predict (regression)
if lr is not None and scaler_reg is not None:
    X_reg_scaled = scaler_reg.transform(X_reg)
    pred_mood_change = lr.predict(X_reg_scaled)[0]

    # Display regression result
    with col1:
        st.metric(label="Predicted Mood Improvement (0–10)", value=f"{float(pred_mood_change):.2f}")
        st.write("Predicted Post Mood (Baseline + Improvement):", min(10, baseline_mood + pred_mood_change).__round__(2))
else:
    with col1:
        st.warning("Regression model or scaler could not be loaded. Cannot predict mood improvement.")


# Classification (if available)
with col2:
    if clf is not None and scaler_clf is not None and le is not None:
        X_clf_scaled = scaler_clf.transform(X_reg)
        pred_class = clf.predict(X_clf_scaled)[0]
        pred_label = le.inverse_transform([pred_class])[0]
        st.metric(label="Predicted Detox Difficulty", value=pred_label)
    else:
        st.info("Classification model not available. Upload `logistic_difficulty_model.joblib`, `scaler_clf.joblib`, and `label_encoder_difficulty.joblib` into the models/ folder.")

# ---------------------------
# Bottom: Data & Visuals
# ---------------------------
st.markdown("---")
st.subheader("Dataset Summary & Visuals")

# Try to load dataset if exists
data_loaded = False
csv_path_candidates = [
    os.path.join(DATA_DIR, "Digital_Detoxx_Final_RealBalanced.csv"),
    os.path.join(DATA_DIR, "Digital_Detoxx_Final_200.csv"),
    os.path.join(DATA_DIR, "Digital_Detoxx_Realistic_Accuracy.csv"),
    os.path.join(DATA_DIR, "Digital_Detoxx_Final_RealBalanced.csv"),
    os.path.join(DATA_DIR, "Digital_Detoxx_Final.csv"),
]
df = None
for p in csv_path_candidates:
    if os.path.exists(p):
        df = pd.read_csv(p)
        data_loaded = True
        break

if not data_loaded:
    st.warning("Dataset not found in data/ folder. Place your CSV (final dataset) inside 'data/' for dataset visuals.")
else:
    st.write(f"Loaded dataset: `{os.path.basename(p)}` — shape: {df.shape}")
    st.markdown("**Head of dataset:**")
    st.dataframe(df.head())

    # Simple stats
    with st.expander("Show summary statistics"):
        st.dataframe(df.describe(include='all').T)

    # Charts
    fig, ax = plt.subplots(1, 2, figsize=(12,4))
    sns.boxplot(x=df["Difficulty Level"], y=df["Stress Reduction"], ax=ax[0])
    ax[0].set_title("Stress Reduction by Difficulty Level")
    sns.histplot(df["Mood Change"], bins=12, ax=ax[1])
    ax[1].set_title("Distribution of Mood Change")
    st.pyplot(fig)

    # Correlation heatmap (numeric only)
    num_cols = df.select_dtypes(include=["number"]).columns.tolist()
    if len(num_cols) >= 3:
        fig2, ax2 = plt.subplots(figsize=(8,6))
        sns.heatmap(df[num_cols].corr(), annot=True, fmt=".2f", cmap="coolwarm", center=0, ax=ax2)
        st.pyplot(fig2)

# ---------------------------
# Footer: How to use / Troubleshooting
# ---------------------------
st.markdown("---")
st.markdown("""
**How to use this app in your repo**

1. Put your models in the repo root `models/` folder:
   - `linear_mood_change_model.joblib`
   - `scaler_reg.joblib`
   - `logistic_difficulty_model.joblib` (optional)
   - `scaler_clf.joblib` (optional)
   - `label_encoder_difficulty.joblib` (optional)

2. Put your final CSV in `data/` (recommended filename: `Digital_Detoxx_Final_RealBalanced.csv`).

3. From repo root run:
   `streamlit run dashboard/streamlit_app.py`

**If the app cannot find models or data, check file paths and ensure the files are in the correct folders.**
""")
